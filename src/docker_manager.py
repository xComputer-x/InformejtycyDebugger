from __future__ import unicode_literals

import pexpect
import subprocess
from uuid import uuid4

import docker_response_status as DckStatus
from server import DEBUGGER_TIMEOUT, DEBUGGER_CPU_LIMIT, CGROUP_NAME

class DockerManager():
	
	def __init__(self, debug_dir: str, gdb_printers_dir: str) -> None:
		self.debug_dir = debug_dir
		self.gdb_printers_dir = gdb_printers_dir
		
		self.debug_image_name = "informejtycy_debugger"
	
	'''
	For debugger
	'''

	def build_for_debugger(self, executable_file_name: str, source_file_name: str, stdin_file_name: str) -> tuple[str, bytes]:
		try:
			stdout = subprocess.check_output(["cp", f"{self.gdb_printers_dir}/printers.py", self.debug_dir])
		except:
			return (DckStatus.internal_docker_manager_error, b"")

		self.clear_images()

		content = "\n".join([
			f"# This file was automatically generated by {__name__}",
			f"FROM debian:sid",
			f"RUN apt-get update -y && apt-get upgrade -y",
			f"RUN apt install -y gdb",
			f"RUN mkdir -p app/received",															# Make work directory
			f"RUN groupadd --system appgroup && useradd --system --no-create-home --gid appgroup appuser",							# Make user without root permissions
			f"RUN mkdir -p /usr/share/gcc/13/python/libstdcxx/v6/",									# Making directory for printers.py (gdb pretty print)
			f"COPY ./printers.py /usr/share/gcc/13/python/libstdcxx/v6/printers.py", 					# Copying printers.py
			f"COPY {executable_file_name} /app/a.out",												# Copying executable .out
			f"COPY {source_file_name} /app/received/{source_file_name}", 							# Copying source .cpp
			f"COPY {stdin_file_name} /app/{stdin_file_name}",
			f"WORKDIR app",
			f"RUN chown appuser:appgroup /app/a.out",												# User is owner of this executable
			f"RUN chmod 700 /app/a.out",															# Permissions
			f"USER appuser",																		# Set current user to created user
		])

		status = ""
		stdout = bytes()

		with open(f"{self.debug_dir}/dockerfile", "w") as f:
			f.write(content)

		try:
			stdout = subprocess.check_output(["docker", "build", "-t", self.debug_image_name, self.debug_dir], stderr=subprocess.STDOUT)
			status = DckStatus.success
		except FileNotFoundError:
			status = DckStatus.internal_docker_manager_error
		except:
			status = DckStatus.docker_build_error

		return (status, stdout)

	def run_for_debugger(self, container_name: str, memory_limit_MB: int) -> pexpect.spawnu:
		process = pexpect.spawnu("docker", ["run", "--rm", "--cap-drop=ALL", "--cap-add=SYS_PTRACE", "--security-opt", "seccomp=unconfined", "--memory-swap=256m", "--read-only", "-v", "/tmp/tmp", f"--cgroup-parent={CGROUP_NAME}", f"--cpus={DEBUGGER_CPU_LIMIT}", "--network=none", "--memory", f"{memory_limit_MB}m", "--name", container_name, "-i", self.debug_image_name, "gdb", "./a.out", "--interpreter=mi3", "--quiet"], timeout=DEBUGGER_TIMEOUT)

		return process

	'''
	Additional methods.
	'''

	def stop_container(self, container_name: str) -> None:
		subprocess.run(["docker", "kill", container_name], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

	def clear_images(self) -> tuple[str, bytes]:
		status = ""
		stdout = bytes()
		
		try:
			stdout = subprocess.check_output(["docker", "system", "prune"], input='y'.encode('utf-8'))
			status = DckStatus.success
		except Exception as e:
			status = DckStatus.server_error
		
		return (status, stdout)
